#!/usr/bin/env bash
#
#  SPYKE commands
#  

### Linux commands: 
#   -mvn
#   -find
#   -tee
#   -chmod
#   -cp
#   -rm
#   -sed
#   -grep
#   -echo
#   -cat
#   -systemctl
#   -journalctl
#   -netstat
#   -iptables
#   -tc
#   -vcgencmd

MVN=/usr/bin/mvn
FIND=/usr/bin/find
TEE=/usr/bin/tee
CHMOD=/bin/chmod    # not used
CP=/bin/cp
RM=/bin/rm
SED=/bin/sed
GREP=/bin/grep
ECHO=/bin/echo
CAT=/bin/cat
SYSTEMCTL=/bin/systemctl
JOURNALCTL=/bin/journalctl
NETSTAT=/bin/netstat
IPTABLES=/sbin/iptables
TC=/sbin/tc         # not used
VCGENCMD=/opt/vc/bin/vcgencmd

### variables:
#   -VERIFIED - verify if the sistem has the programs needed
#   -SCRIPT - path to spyke script
#   -TARGET - path to spyke target
#   -SPYKE_JAR - path to spyke jar file
#   -IPTABLES_CONF - path to iptables.conf
#   -SERVICE - spyke systemd service
#   -DNSMASQ_CONF - path to file dnsmasq.conf
#   -HOSTAPD_CONF - path to file hostapd.conf
#   -HOSTAPD_DEFAULT - path to default hostapd file
#   -DHCP_CONF - path to file dhcpcd.conf
#   -SYSCTL_CONF - path to file sysctl.conf for packet forward
#   -IPTABLES_LOG_CONF - path to iptables log config file; redirect log to specified file
#   -DNS_LEASE - path to dnsmasq lease file
#   -RC_LOCAL - path to rc.local file; bootstrap scrip

# to be replaced
PWD=TOBEREPLACED
SPYKE=$PWD/core
POM_FILE=$SPYKE/pom.xml
SCRIPT=$SPYKE/script
CONFIG=$SCRIPT/config
TARGET=$SPYKE/target
SPYKE_JAR=$TARGET/core-1.1.0.jar
IPTABLES_CONF=/etc/iptables.ipv4.conf
SERVICE=/etc/systemd/system/spyke.service
DNSMASQ_CONF=/etc/dnsmasq.conf
HOSTAPD_CONF=/etc/hostapd/hostapd.conf
HOSTAPD_DEFAULT=/etc/default/hostapd
DHCP_CONF=/etc/dhcpcd.conf
SYSCTL_CONF=/etc/sysctl.conf
IPTABLES_LOG_CONF=/etc/rsyslog.d/iptables.conf
DNS_LEASE=/var/lib/misc/dnsmasq.leases
RC_LOCAL=/etc/rc.local

require_superuser() {
    if [[ $UID != 0 ]]; then
        echo "Root privilege required."
        echo "Please run this script with sudo."
        exit 1
    fi
}

wait_for_db() {
    while [ ! -f $SPYKE/target/spyke.db ]
    do
        $ECHO "waiting for db file..."
        sleep 1
    done
}

check_dependencies() {

    require_superuser

    hasMissingDependencies=false
    if ! ldconfig -p | grep libpcap &> /dev/null; then
        echo "libpcap-dev is not installed."
        if [ "$hasMissingDependencies" = false ]; then
            hasMissingDependencies=true
        fi
    fi
    if ! which hostapd &> /dev/null; then
        echo "hostapd is not installed."
        if [ "$hasMissingDependencies" = false ]; then
            hasMissingDependencies=true
        fi
    fi
    if ! which dnsmasq &> /dev/null; then
        echo "dnsmasq is not installed."
        if [ "$hasMissingDependencies" = false ]; then
            hasMissingDependencies=true
        fi
    fi
    if ! which java &> /dev/null; then
        echo "java is not installed."
        if [ "$hasMissingDependencies" = false ]; then
            hasMissingDependencies=true
        fi
    fi
    if ! which mvn &> /dev/null; then
        echo "maven is not installed."
        if [ "$hasMissingDependencies" = false ]; then
            hasMissingDependencies=true
        fi
    fi
    if ! which sqlite3 &> /dev/null; then
        echo "sqlite3 is not installed."
        if [ "$hasMissingDependencies" = false ]; then
            hasMissingDependencies=true
        fi
    fi
    if ! which cron &> /dev/null; then
        echo "cron is not installed."
        if [ "$hasMissingDependencies" = false ]; then
            hasMissingDependencies=true
        fi
    fi
    if ! which iptables &> /dev/null; then
        echo "iptables is not installed."
        if [ "$hasMissingDependencies" = false ]; then
            hasMissingDependencies=true
        fi
    fi

    if [ "$hasMissingDependencies" = true ] ; then
        echo "Installing the required dependencies? [y/N]"
        read option
        if [ "$option" = "y" ] || [ "$option" = "Y" ]; then
            if ! which apt &> /dev/null; then
                echo "Unknow command apt, is this debian based linux?"
                exit 1
            else
                apt-get update -y
                apt-get install hostapd dnsmasq \
                        openjdk-8-jdk maven libpcap-dev \
                        sqlite3 cron iptables -y
            fi
        else
            echo "Fail installing the required dependencies."
            exit 1
        fi
    else
        echo "all dependencies are installed."
    fi
}

spyke_configuration() {

    require_superuser

    $ECHO "[Unit]
Description=spyke - A Network Monitor
After=syslog.target
After=network.target

[Service]
WorkingDirectory=$TARGET
User=pi
Type=simple
StandardInput=$TARGET/input
StandardOutput=syslog
StandardError=syslog
SyslogIdentifier=spyke
ExecStart=+$SPYKE_JAR

[Install]
WantedBy=multi-user.target
" > $SERVICE

    $CP $CONFIG/hostapd.conf $HOSTAPD_CONF
    if $GREP -q "dhcp-script=$SCRIPT/device" $DNSMASQ_CONF; then
        $ECHO "file $DNSMASQ_CONF already has dhcp-script=$SCRIPT/device"
    else
        $CP $CONFIG/dnsmasq.conf $DNSMASQ_CONF
        $ECHO "dhcp-script=$SCRIPT/device" | $TEE --append $DNSMASQ_CONF
    fi
    
    if $GREP -q "# add for spyke" $DHCP_CONF ; then
        $ECHO "file $DHCP_CONF already part added for spyke"
    else
        $ECHO "# add for spyke
interface wlan0 
static ip_address=192.168.8.1/24
denyinterfaces eth0
denyinterfaces wlan0" >> $DHCP_CONF
    fi

    $ECHO "# add for spyke
DAEMON_CONF=\"/etc/hostapd/hostapd.conf\"" > $HOSTAPD_DEFAULT
    $ECHO "# add for spyke
net.ipv4.ip_forward=1" > $SYSCTL_CONF

    $ECHO "spyke configuration done"
    ## update iptables-restore 
    #if $GREP -q "iptables-restore < $IPTABLES_CONF" $RC_LOCAL; then
    #    $ECHO "file $RC_LOCAL already has iptables-restore < $IPTABLES_CONF"
    #else
    #    ## FIXME new version won't use iptables on rc.local
    #    $ECHO "file $RC_LOCAL does not have iptables-restore < $IPTABLES_CONF"
    #    $SED -i "/fi/a \iptables-restore < $IPTABLES_CONF\\" $RC_LOCAL
    #fi
}

install() {

    require_superuser

    if [ "`$SYSTEMCTL is-active spyke`" == "active" ]; then
        $ECHO "spyke already is installed and running"
        exit 0
    fi

    check_dependencies
    spyke_configuration
    launch
}

uninstall() {

    terminate

    # rm spyke service
    $RM $SERVICE
    # rm the handle new connected device script line added
    $SED -i "/dhcp-script=$SCRIPT/device/d" $DNSMASQ_CONF
    # deactivate iptables on /etc/rc.local file
    #$SED -i "/iptables-restore < \/etc\/iptables.ipv4.conf/d" $RC_LOCAL

    # rm iptables log config file
    $RM $IPTABLES_LOG_CONF
    $SYSTEMCTL restart rsyslog

    $ECHO "spyke uninstalled"
}

launch() {

    require_superuser

    if [ "`$SYSTEMCTL is-active spyke`" != "active" ]; then
        $MVN clean package -f $POM_FILE
        sleep 1
        $SYSTEMCTL enable spyke
        $SYSTEMCTL start spyke

        # wait spyke start and create spyke.db
        wait_for_db

        $SYSTEMCTL enable dnsmasq
        $SYSTEMCTL enable hostapd
        $SYSTEMCTL stop hostapd
        $SYSTEMCTL stop dnsmasq
        $RM $DNS_LEASE
        sleep 1
        $SYSTEMCTL start dnsmasq
        $SYSTEMCTL start hostapd

        $IPTABLES -t nat -A POSTROUTING -o eth0 -j MASQUERADE
        # FIXME this should be replaced with pcap4j 
        $CP $CONFIG/iptables.conf $IPTABLES_LOG_CONF
        $SYSTEMCTL restart rsyslog

        $ECHO "spyke is configured and running."
    else
        $ECHO "spyke is already running."
    fi
}

terminate() {

    require_superuser

    if [ "`$SYSTEMCTL is-active spyke`" == "active" ]; then
        $SYSTEMCTL stop spyke
    fi

    $SYSTEMCTL disable spyke
    $MVN clean -f $POM_FILE

    if [ "`$SYSTEMCTL is-active hostapd`" == "active" ]; then
        $SYSTEMCTL stop hostapd
    fi
    if [ "`$SYSTEMCTL is-active dnsmasq`" == "active" ]; then
        $SYSTEMCTL stop dnsmasq
    fi
    $RM $DNS_LEASE
    sleep 1
    $SYSTEMCTL disable dnsmasq
    $SYSTEMCTL disable hostapd
    # rm spyke iptables
    #$RM $IPTABLES_CONF
    # delete all iptables rules
    $IPTABLES -P INPUT ACCEPT
    $IPTABLES -P FORWARD ACCEPT
    $IPTABLES -P OUTPUT ACCEPT
    $IPTABLES -t nat -F
    $IPTABLES -t mangle -F
    $IPTABLES -F
    $IPTABLES -X

    $ECHO "Dns lease and iptables demoved"
}

restart() {
    require_superuser
    terminate
    sleep 3
    launch
}

reinstall() {
    require_superuser
    uninstall
    sleep 3
    install
}

status() {

    $ECHO "last 100 lines from syslog:"
    #   log spyke from this boot
    $ECHO "`$JOURNALCTL -u spyke -b -n 100`"
    $ECHO ""

}

check() {
    $ECHO ""
    $ECHO "Check system open ports:"
    $NETSTAT -antp

    $ECHO ""
    $ECHO "Dnsmasq lease file:"
    $CAT $DNS_LEASE

    $ECHO ""
    $ECHO "Database spyke.db location:"
    $FIND $PWD -name "*.db"

    $ECHO ""
    $ECHO "System's temperature:"
    $VCGENCMD measure_temp

    $ECHO ""
}

firewall(){

    require_superuser

    $ECHO ""
    $ECHO "Iptables rules:"
    $IPTABLES -nvL
    $ECHO ""
}

howtouse() {

    $ECHO "Usage:
    spyke [options]
example:
    spyke -h
options:
    -cd, check_dependencies check missing dependencies
    -i,  install            install spyke to the system
    -u,  unisntall          remove spyke from the system
    -l,  launch             start spyke
    -t,  terminate          stop spyke
    -r,  restart            stop spyke and start it again after 3 second
    -ui, reinstall          uninstall spyke and install it again after 3 second
    -s,  status             show logs
    -c,  check              show hardware temperature; open ports, connected devices, database file location
    -f,  firewall           show iptables rules
    -h,  help               show usage
note:
    You must have PERMISSION to run spyke or simply add SUDO at the beginning
    Any other option or input shows this message";
}

case "$1" in

  -conf) spyke_configuration;;

  -cd|check_dependencies) check_dependencies;; 

  -i|install)   install;;

  -u|uninstall) uninstall;;

  -l|launch)    launch;;

  -t|terminate) terminate;;

  -r|restart)   restart;;

  -ui|reinstall)   reinstall;;

  -s|status)    status;;

  -c|check)     check;;

  -f|firewall)  firewall;;

  *)    howtouse;;

esac 

exit 0
